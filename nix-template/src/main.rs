#![allow(clippy::module_name_repetitions)]

use std::fmt::Write as _;
use std::fs;
use std::fs::OpenOptions;
use std::io::Write as _;
use std::path::{Path, PathBuf};
use std::sync::Arc;

use clap::{Parser, Subcommand};
use console::Emoji;
use eyre::Report;
use ignore::types::TypesBuilder;
use ignore::{Walk, WalkBuilder};
use indicatif::ProgressBar;
use linkme::distributed_slice;
use log::info;
use minijinja::value::Value;
use minijinja::{context, Environment, Source};
use once_cell::sync::Lazy;

use crate::spinner::{
    delete_global_progress_bar, new_global_progress_bar, with_global_progress_bar,
};
use crate::store::{delete_global_store, set_global_store, FileStore};

const EMOJI_ROCKET: Emoji = Emoji("üöÄ ", "");
const EMOJI_WRITE: Emoji = Emoji("üìù ", "");

#[macro_use]
mod utils;
mod spinner;
mod store;

// type Result<T, E = Box<dyn Error + Send + Sync>> = std::result::Result<T, E>;
type Result<T, E = Report> = std::result::Result<T, E>;

const LOCK_FORMAT: usize = 0;

#[distributed_slice]
static UTILS: [(
    /* sig */ &'static str,
    /* doc */ &'static str,
    /* func */ Lazy<Value>,
)] = [..];

fn populate_environment(env: &mut Environment) {
    for (sig, _, func) in UTILS {
        let name = sig.split_once('(').unwrap().0;
        info!("Adding helper function: {}", name);
        env.add_global(name, (*func).clone());
    }
}

fn available_functions() -> String {
    let mut buffer = "Available functions:\n".to_string();
    for (sig, doc, _) in UTILS {
        let (s1, s2) = doc.trim().trim_end_matches('.').split_at(1);
        let doc = format!("{}{}", s1.to_lowercase(), s2);
        writeln!(buffer, "  * `{}` - {}", sig, doc).unwrap();
    }
    buffer
}

/// Utility to instantiate a nix file template.
///
/// This utility accepts a valid `minijinja` template and outputs a file into stdout.
#[derive(Parser)]
#[command(author, version, about, after_long_help = available_functions())]
struct Args {
    #[clap(subcommand)]
    command: Option<Commands>,
    /// Path to the directory containing the template.
    #[arg(default_value = ".")]
    path: PathBuf,
    /// The lock file to use.
    #[arg(short, long, default_value = "template.lock")]
    lock: PathBuf,
}

#[derive(Subcommand, Copy, Clone, Eq, PartialEq, Default)]
enum Commands {
    /// Instantiate the template (default).
    /// Unused cache values in lock file will NOT be removed.
    #[default]
    Instantiate,
    /// Update the lock file.
    /// Unused cache values in lock file will be removed.
    /// No file will be generated.
    Update,
}

fn walker(path: &Path) -> Result<Walk> {
    let mut builder = WalkBuilder::new(path);

    let mut types_builder = TypesBuilder::new();
    types_builder.add("tmpl", "*.tmpl.nix")?;
    types_builder.select("tmpl");
    let types = types_builder.build()?;

    builder.types(types);
    Ok(builder.build())
}

fn main() -> Result<()> {
    pretty_env_logger::init();
    color_eyre::install()?;
    let args = Args::parse();
    let command = args.command.unwrap_or_default();

    let mut env = Environment::new();
    let source = Source::from_path(&args.path);
    env.set_source(source);
    populate_environment(&mut env);

    let store = FileStore::with(
        OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .open(&args.lock)?,
        match command {
            // In instantiate mode, we use cached values in lock file as much as possible.
            // If a field is not present, we populate it with the current value.
            Commands::Instantiate => true,
            // In update mode, we always update the lock file with the current values.
            Commands::Update => false,
        },
    )?;
    set_global_store(Arc::new(store.clone()));

    new_global_progress_bar(ProgressBar::new_spinner);

    for file in walker(&args.path)? {
        let file = file?;
        if file.path().is_dir() {
            continue;
        }
        with_global_progress_bar(|pb| {
            pb.println(format!(
                "{EMOJI_ROCKET}Processing {}",
                file.path().display()
            ))
        });
        let source_path = file.path().strip_prefix(".")?;
        let target_path = file.path().with_file_name(format!(
            "{}.nix",
            file.file_name()
                .to_string_lossy()
                .trim_end_matches(".tmpl.nix")
        ));

        match command {
            Commands::Instantiate => {
                // We write to file if only in instantiate mode.
                let mut file = fs::File::create(&target_path)?;
                writeln!(file, "# GENERATED BY nix-template. DO NOT EDIT.")?;
                env.get_template(&source_path.to_string_lossy())?
                    .render_to_write(context!(), file)?;
            }
            Commands::Update => {
                // We don't write to file in update mode.
                env.get_template(&source_path.to_string_lossy())?
                    .render_to_write(context!(), &mut std::io::sink())?;
            }
        }
    }

    // All templates has been rendered, we can now save the lock file.
    // Need to remove the global store to make sure we have a unique reference to the store.
    with_global_progress_bar(|pb| pb.println(format!("{EMOJI_WRITE}Writing lock file...")));
    delete_global_store();
    store.persist()?;

    delete_global_progress_bar();
    Ok(())
}
